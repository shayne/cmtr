from __future__ import annotations

from pathlib import Path
import textwrap
import tomllib

from .config import Config
from .core import generate_message
from .errors import UserError
from .git import get_hooks_dir, run_git

HOOK_MARKER = "# cmtr hook v1"


def install_hook(repo_root: Path, force: bool) -> Path:
    hooks_dir = get_hooks_dir(repo_root)
    hooks_dir.mkdir(parents=True, exist_ok=True)
    hook_path = hooks_dir / "prepare-commit-msg"
    if hook_path.exists() and not _is_our_hook(hook_path):
        if not force:
            raise UserError(
                "prepare-commit-msg hook already exists. Use --force to overwrite."
            )
    local_checkout = _detect_local_checkout()
    hook_path.write_text(_hook_script_for(local_checkout), encoding="utf-8")
    hook_path.chmod(0o755)
    return hook_path


def uninstall_hook(repo_root: Path) -> Path:
    hooks_dir = get_hooks_dir(repo_root)
    hook_path = hooks_dir / "prepare-commit-msg"
    if not hook_path.exists():
        raise UserError("No prepare-commit-msg hook found.")
    if not _is_our_hook(hook_path):
        raise UserError("prepare-commit-msg hook was not installed by cmtr.")
    hook_path.unlink()
    return hook_path


def run_prepare_commit_msg(
    message_path: Path,
    source: str | None,
    sha: str | None,
    repo_root: Path,
    config: Config,
    api_key: str | None,
) -> int:
    if _should_skip_source(source):
        return 0
    if _is_rebase_in_progress(repo_root):
        return 0
    if _is_fixup_or_squash(message_path):
        return 0
    if _has_existing_message(message_path):
        return 0
    try:
        message = generate_message(repo_root=repo_root, config=config, api_key=api_key)
        _write_message_prepend(message_path, message)
        return 0
    except Exception as exc:
        append_failure_comment(message_path, str(exc))
        return 0


def _should_skip_source(source: str | None) -> bool:
    if not source:
        return False
    return source in {"message", "merge", "squash", "commit", "tag", "template"}


def _write_message(path: Path, message: str) -> None:
    text = message.strip() + "\n"
    path.write_text(text, encoding="utf-8")


def _write_message_prepend(path: Path, message: str) -> None:
    existing = ""
    if path.exists():
        existing = path.read_text(encoding="utf-8")
    message_text = message.strip()
    if existing:
        text = f"{message_text}\n\n{existing}"
    else:
        text = f"{message_text}\n"
    path.write_text(text, encoding="utf-8")


def append_failure_comment(path: Path, error: str) -> None:
    comment = f"# cmtr failed: {error}\n"
    existing = ""
    if path.exists():
        existing = path.read_text(encoding="utf-8")
    if existing and not existing.endswith("\n"):
        existing += "\n"
    path.write_text(existing + comment, encoding="utf-8")


def _is_our_hook(path: Path) -> bool:
    try:
        contents = path.read_text(encoding="utf-8")
    except OSError:
        return False
    return HOOK_MARKER in contents


def _git_dir(repo_root: Path) -> Path:
    output = run_git(["rev-parse", "--git-dir"], repo_root).strip()
    git_dir = Path(output)
    if not git_dir.is_absolute():
        git_dir = repo_root / git_dir
    return git_dir


def _is_rebase_in_progress(repo_root: Path) -> bool:
    git_dir = _git_dir(repo_root)
    return (git_dir / "rebase-merge" / "interactive").exists() or (
        git_dir / "rebase-apply"
    ).exists()


def _is_fixup_or_squash(message_path: Path) -> bool:
    if not message_path.exists():
        return False
    for line in message_path.read_text(encoding="utf-8").splitlines():
        stripped = line.lstrip()
        if not stripped or stripped.startswith("#"):
            continue
        if stripped.startswith("fixup") or stripped.startswith("squash"):
            return True
    return False


def _has_existing_message(message_path: Path) -> bool:
    if not message_path.exists():
        return False
    for line in message_path.read_text(encoding="utf-8").splitlines():
        if line.startswith("#"):
            break
        if line.strip():
            return True
    return False


def _hook_script() -> str:
    return _hook_script_for(None)


def _hook_script_for(local_checkout: Path | None) -> str:
    if local_checkout:
        repo_path = local_checkout.as_posix()
        script = f"""#!/bin/sh
{HOOK_MARKER}
# Generated by: cmtr --hook

CMTR_REPO="{repo_path}"

if [ -d "$CMTR_REPO" ] && [ -f "$CMTR_REPO/pyproject.toml" ]; then
  if command -v mise >/dev/null 2>&1; then
    (cd "$CMTR_REPO" && mise exec -- uv run cmtr prepare-commit-msg "$@")
  elif command -v uv >/dev/null 2>&1; then
    (cd "$CMTR_REPO" && uv run cmtr prepare-commit-msg "$@")
  else
    echo "cmtr: uv not found; skipping commit message generation" >&2
  fi
else
  if command -v uvx >/dev/null 2>&1; then
    uvx cmtr@latest prepare-commit-msg "$@"
  else
    echo "cmtr: uvx not found; skipping commit message generation" >&2
  fi
fi
"""
        return textwrap.dedent(script)
    script = f"""#!/bin/sh
{HOOK_MARKER}
# Generated by: cmtr --hook

if command -v uvx >/dev/null 2>&1; then
  uvx cmtr@latest prepare-commit-msg "$@"
else
  echo "cmtr: uvx not found; skipping commit message generation" >&2
fi
"""
    return textwrap.dedent(script)


def _detect_local_checkout() -> Path | None:
    current = Path(__file__).resolve()
    for parent in current.parents:
        pyproject = parent / "pyproject.toml"
        if pyproject.exists() and (parent / "src" / "cmtr").exists():
            if _is_cmtr_pyproject(pyproject) and (parent / ".git").exists():
                return parent
            return None
    return None


def _is_cmtr_pyproject(path: Path) -> bool:
    try:
        data = tomllib.loads(path.read_text(encoding="utf-8"))
    except OSError:
        return False
    project = data.get("project", {})
    if not isinstance(project, dict):
        return False
    return project.get("name") == "cmtr"
